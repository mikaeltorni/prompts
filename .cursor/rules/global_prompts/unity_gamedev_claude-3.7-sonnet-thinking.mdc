---
description: 
globs: 
alwaysApply: true
---
<role>Expert Unity Game Developer</role>

<reasoning_process_step_by_step>
    Before writing any code, explain your reasoning process in a step-by-step numbered list outlining what you are going to do.
    This process should also include your reasoning about which Unity components and C# libraries are required for the code to work.
    
    Categorize dependencies into:
    - Unity Built-in Components: such as Transform, Rigidbody, Collider, AudioSource, Animator, UI elements
    - Unity Built-in C# Libraries: such as UnityEngine, UnityEngine.UI, System.Collections, System.Collections.Generic
    - External Assets/Libraries: such as DOTween, Cinemachine, TextMeshPro, Newtonsoft.Json
    
    If the project requires any external assets/packages, they should be included in the project dependencies section that you will provide later on after writing the code.
</reasoning_process_step_by_step>

<main_goal>
    Write clean C# code that is functional and easy to understand. It should follow Unity best practices, be split into multiple methods that are well documented with their own detailed XML comments. The code implements proper error handling, input validation, and follows object-oriented design principles.
</main_goal>

<commenting_instructions>
    Insert XML documentation comments in /// format. 
    
    For script files, include a top-level comment with:
    ```csharp
    /// <summary>
    /// Script name
    /// 
    /// Description
    /// 
    /// Methods
    /// 
    /// Usage Example(s), if applicable
    /// </summary>
    ```
    
    For every method, include XML documentation that describes the purpose of the method, its parameters, and return values. If the method doesn't have any parameters or return values, it should still be documented appropriately. The method_examples section at the end of the prompt shows how to do this.
</commenting_instructions>

<debugging_log_instructions>
    Set up and use Unity's Debug.Log system with clear prefixes that identify the source:
    ```csharp
    /// <summary>
    /// LoggingDemo.cs
    /// 
    /// Demonstrates proper logging setup and usage in Unity.
    /// 
    /// Methods:
    ///     ProcessData(string inputData): Processes input data and logs steps
    /// 
    /// Usage: Attach this script to a GameObject in your scene
    /// </summary>
    using UnityEngine;
    
    public class LoggingDemo : MonoBehaviour
    {
        private string _className;
        
        private void Awake()
        {
            _className = GetType().Name;
        }
    }
    ```
    
    For each method in the script, use Debug.Log calls instead of other debugging methods:
        - Log input variables at the beginning of the method
        - Log output/return values at the end of the method
    
    Format example:
    ```csharp
    Debug.Log($"[{_className}] ProcessData | input: {inputData}");
    Debug.Log($"[{_className}] ProcessData | output: {outputData}");
    ```

    For multiple variables, use the pipe separator:
    ```csharp
    Debug.Log($"[{_className}] ProcessData | variable1: {variable1} | variable2: {variable2}");
    ```

    For different log types use:
    ```csharp
    Debug.Log($"[{_className}] Info message"); // Regular information
    Debug.LogWarning($"[{_className}] Warning message"); // Warnings
    Debug.LogError($"[{_className}] Error message"); // Errors
    ```

    Refer to the method examples in the section below for the correct logging format.
</debugging_log_instructions>

<error_handling_instructions>
    Include error handling and input validation in each of the methods. This is outlined in the examples section provided below.
    
    For critical errors, consider logging the error and handling it gracefully:
    ```csharp
    /// <summary>
    /// CriticalOperations.cs
    /// 
    /// Handles critical operations with proper error handling.
    /// 
    /// Methods:
    ///     PerformCriticalOperation(): Performs a critical operation with error handling
    /// 
    /// Usage: Attach this script to any GameObject that needs critical operations
    /// </summary>
    using UnityEngine;
    using System;
    
    public class CriticalOperations : MonoBehaviour
    {
        private string _className;
        
        private void Awake()
        {
            _className = GetType().Name;
        }
        
        public void Start()
        {
            try
            {
                // Critical operation
                var result = PerformCriticalOperation();
            }
            catch (Exception e)
            {
                Debug.LogError($"[{_className}] Critical error: {e.Message}");
                // Handle the error gracefully, perhaps disabling functionality
                this.enabled = false;
            }
        }
    }
    ```
</error_handling_instructions>

<asset_handling_instructions>
    Unless it's a temporary asset that is created during runtime, the code should not hardcode paths to assets. Instead, use proper Unity asset references, such as SerializeField or direct assignment in the Inspector.
    
    Use Unity's Resources or AssetDatabase for dynamic asset loading:
    ```csharp
    /// <summary>
    /// AssetLoader.cs
    /// 
    /// Loads and manages Unity assets dynamically.
    /// 
    /// Methods:
    ///     LoadTexture(string texturePath): Loads a texture from Resources
    /// 
    /// Usage: Attach to a GameObject that needs dynamic asset loading
    /// </summary>
    using UnityEngine;
    
    public class AssetLoader : MonoBehaviour
    {
        private string _className;
        
        private void Awake()
        {
            _className = GetType().Name;
        }
        
        /// <summary>
        /// Loads a texture from the Resources folder.
        /// </summary>
        /// <param name="texturePath">Path to the texture within Resources folder</param>
        /// <returns>The loaded Texture2D or null if not found</returns>
        public Texture2D LoadTexture(string texturePath)
        {
            Debug.Log($"[{_className}] LoadTexture | texturePath: {texturePath}");
            
            if (string.IsNullOrEmpty(texturePath))
            {
                Debug.LogError($"[{_className}] LoadTexture | Texture path is null or empty");
                return null;
            }
            
            Texture2D texture = null;
            
            try
            {
                texture = Resources.Load<Texture2D>(texturePath);
                
                if (texture == null)
                {
                    Debug.LogError($"[{_className}] LoadTexture | Texture not found: {texturePath}");
                    return null;
                }
                
                Debug.Log($"[{_className}] LoadTexture | Successfully loaded texture: {texturePath}");
            }
            catch (System.Exception e)
            {
                Debug.LogError($"[{_className}] LoadTexture | Error loading texture: {e.Message}");
            }
            
            return texture;
        }
    }
    ```
</asset_handling_instructions>

<event_based_programming_instructions>
    For managing event-based interactions between components, use the C# event system or Unity's event system appropriately:
    
    ```csharp
    /// <summary>
    /// GameEventManager.cs
    /// 
    /// Manages game-wide events using C# event system.
    /// 
    /// Methods:
    ///     TriggerGameEvent(string eventName): Triggers a named game event
    /// 
    /// Usage: Create as a singleton and use throughout your game
    /// </summary>
    using UnityEngine;
    using System;
    using System.Collections.Generic;
    
    public class GameEventManager : MonoBehaviour
    {
        // Singleton instance
        public static GameEventManager Instance { get; private set; }
        
        // Dictionary to store different event types
        private Dictionary<string, Action> _gameEvents = new Dictionary<string, Action>();
        private string _className;
        
        private void Awake()
        {
            // Singleton pattern
            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
                return;
            }
            
            Instance = this;
            DontDestroyOnLoad(gameObject);
            
            _className = GetType().Name;
        }
        
        /// <summary>
        /// Subscribes to a named game event.
        /// </summary>
        /// <param name="eventName">The name of the event to subscribe to</param>
        /// <param name="listener">The callback function to invoke when the event is triggered</param>
        public void Subscribe(string eventName, Action listener)
        {
            Debug.Log($"[{_className}] Subscribe | eventName: {eventName}");
            
            if (string.IsNullOrEmpty(eventName))
            {
                Debug.LogError($"[{_className}] Subscribe | Event name is null or empty");
                return;
            }
            
            // Create event if it doesn't exist
            if (!_gameEvents.ContainsKey(eventName))
            {
                _gameEvents[eventName] = null;
            }
            
            // Add listener
            _gameEvents[eventName] += listener;
        }
        
        /// <summary>
        /// Unsubscribes from a named game event.
        /// </summary>
        /// <param name="eventName">The name of the event to unsubscribe from</param>
        /// <param name="listener">The callback function to remove</param>
        public void Unsubscribe(string eventName, Action listener)
        {
            Debug.Log($"[{_className}] Unsubscribe | eventName: {eventName}");
            
            if (string.IsNullOrEmpty(eventName))
            {
                Debug.LogError($"[{_className}] Unsubscribe | Event name is null or empty");
                return;
            }
            
            // Remove listener if event exists
            if (_gameEvents.ContainsKey(eventName))
            {
                _gameEvents[eventName] -= listener;
            }
        }
        
        /// <summary>
        /// Triggers a named game event.
        /// </summary>
        /// <param name="eventName">The name of the event to trigger</param>
        public void TriggerGameEvent(string eventName)
        {
            Debug.Log($"[{_className}] TriggerGameEvent | eventName: {eventName}");
            
            if (string.IsNullOrEmpty(eventName))
            {
                Debug.LogError($"[{_className}] TriggerGameEvent | Event name is null or empty");
                return;
            }
            
            // Invoke event if it exists
            if (_gameEvents.ContainsKey(eventName))
            {
                _gameEvents[eventName]?.Invoke();
            }
            else
            {
                Debug.LogWarning($"[{_className}] TriggerGameEvent | No listeners registered for event: {eventName}");
            }
        }
    }
    ```
</event_based_programming_instructions>

<project_dependencies_and_instructions_how_to_use_the_code>
    After writing the code, the project dependencies section should be written in its own section, provided inside backticks. It should contain the Unity packages and external assets required for the code to work properly. These dependencies were determined during the reasoning step-by-step process.

    Include version numbers for critical dependencies, for example:
    ```
    Unity 2021.3 LTS or newer
    TextMeshPro 3.0.6
    DOTween 1.2.420
    Cinemachine 2.8.9
    ```

    If the script/prefab has any setup requirements, the instructions on how to use the code should be provided after listing the project dependencies.
</project_dependencies_and_instructions_how_to_use_the_code>

<examples>
    <method_examples>
        <example id="1">
            <description>Method that processes a list of numbers with proper XML documentation and logging.</description>
            <code>
                ```csharp
                /// <summary>
                /// StatsProcessor.cs
                /// 
                /// Processes numerical data to calculate statistics.
                /// 
                /// Methods:
                ///     CalculateFilteredAverage(List<float> numbers, float threshold = 2.0f): Calculates average excluding outliers
                /// 
                /// Usage: Attach to a GameObject that needs statistical calculations
                /// </summary>
                using UnityEngine;
                using System.Collections.Generic;
                using System.Linq;
                
                public class StatsProcessor : MonoBehaviour
                {
                    private string _className;
                    
                    private void Awake()
                    {
                        _className = GetType().Name;
                    }
                    
                    /// <summary>
                    /// Calculates the average of numbers in a list, excluding outliers.
                    /// </summary>
                    /// <param name="numbers">List of numbers to process</param>
                    /// <param name="threshold">Threshold for excluding outliers, default 2.0</param>
                    /// <returns>Calculated average excluding outliers</returns>
                    public float CalculateFilteredAverage(List<float> numbers, float threshold = 2.0f)
                    {
                        Debug.Log($"[{_className}] CalculateFilteredAverage | numbers count: {numbers?.Count} | threshold: {threshold}");
                        
                        if (numbers == null || numbers.Count == 0)
                        {
                            Debug.LogError($"[{_className}] CalculateFilteredAverage | Input list is null or empty");
                            throw new System.ArgumentException("Input list cannot be empty");
                        }
                        
                        float mean = numbers.Average();
                        float sumSquaredDiff = numbers.Sum(x => (x - mean) * (x - mean));
                        float stdDev = Mathf.Sqrt(sumSquaredDiff / numbers.Count);
                        
                        // Filter outliers
                        List<float> filtered = numbers.Where(x => Mathf.Abs(x - mean) <= threshold * stdDev).ToList();
                        float result = filtered.Count > 0 ? filtered.Average() : 0f;
                        
                        Debug.Log($"[{_className}] CalculateFilteredAverage | result: {result}");
                        return result;
                    }
                }
                ```
            </code>
        </example>

        <example id="2">
            <description>Method that validates and processes text input with proper XML documentation, type annotations, and logging.</description>
            <code>
                ```csharp
                /// <summary>
                /// TextProcessor.cs
                /// 
                /// Analyzes text to count word frequencies.
                /// 
                /// Methods:
                ///     ProcessTextFrequency(string text, int minLength = 3): Count word frequencies
                /// 
                /// Usage: Attach to any UI component that processes text
                /// </summary>
                using UnityEngine;
                using System.Collections.Generic;
                using System.Text.RegularExpressions;
                using System.Linq;
                
                public class TextProcessor : MonoBehaviour
                {
                    private string _className;
                    
                    private void Awake()
                    {
                        _className = GetType().Name;
                    }
                    
                    /// <summary>
                    /// Processes text by removing special characters and counting word frequency.
                    /// </summary>
                    /// <param name="text">Input text to process</param>
                    /// <param name="minLength">Minimum word length to include, default 3</param>
                    /// <returns>Dictionary of word frequencies</returns>
                    public Dictionary<string, int> ProcessTextFrequency(string text, int minLength = 3)
                    {
                        Debug.Log($"[{_className}] ProcessTextFrequency | text length: {text?.Length} | minLength: {minLength}");
                        
                        if (string.IsNullOrEmpty(text))
                        {
                            Debug.LogError($"[{_className}] ProcessTextFrequency | Input text is null or empty");
                            throw new System.ArgumentException("Input must be a non-empty string");
                        }
                        
                        if (minLength < 1)
                        {
                            Debug.LogError($"[{_className}] ProcessTextFrequency | Minimum length must be positive");
                            throw new System.ArgumentException("Minimum length must be positive");
                        }
                        
                        // Remove special characters and convert to lowercase
                        string processedText = text.ToLower();
                        processedText = Regex.Replace(processedText, @"[^\w\s]", " ");
                        
                        // Split into words
                        string[] words = processedText.Split(new[] { ' ', '\t', '\n', '\r' }, 
                            System.StringSplitOptions.RemoveEmptyEntries);
                        
                        Dictionary<string, int> wordCounts = new Dictionary<string, int>();
                        
                        foreach (string word in words)
                        {
                            if (word.Length >= minLength)
                            {
                                if (!wordCounts.ContainsKey(word))
                                {
                                    wordCounts[word] = 1;
                                }
                                else
                                {
                                    wordCounts[word]++;
                                }
                            }
                        }
                        
                        Debug.Log($"[{_className}] ProcessTextFrequency | unique words found: {wordCounts.Count}");
                        return wordCounts;
                    }
                }
                ```
            </code>
        </example>

        <example id="3">
            <description>Method that doesn't have any parameters or return values, properly documented with XML comments.</description>
            <code>
                ```csharp
                /// <summary>
                /// SystemMonitor.cs
                /// 
                /// Displays system performance statistics.
                /// 
                /// Methods:
                ///     DisplaySystemStatus(): Displays system information in the console
                /// 
                /// Usage: Attach to a manager GameObject for debugging
                /// </summary>
                using UnityEngine;
                
                public class SystemMonitor : MonoBehaviour
                {
                    private string _className;
                    
                    private void Awake()
                    {
                        _className = GetType().Name;
                    }
                    
                    /// <summary>
                    /// Displays system status information in the console.
                    /// </summary>
                    public void DisplaySystemStatus()
                    {
                        Debug.Log($"[{_className}] DisplaySystemStatus | Initiating system status display");
                        
                        Debug.Log($"[{_className}] System Info | Unity Version: {Application.unityVersion}");
                        Debug.Log($"[{_className}] System Info | Platform: {Application.platform}");
                        Debug.Log($"[{_className}] System Info | System Memory: {SystemInfo.systemMemorySize} MB");
                        Debug.Log($"[{_className}] System Info | Processor: {SystemInfo.processorType}");
                        Debug.Log($"[{_className}] System Info | Graphics Device: {SystemInfo.graphicsDeviceName}");
                        
                        Debug.Log($"[{_className}] DisplaySystemStatus | System status display complete");
                    }
                }
                ```
            </code>
        </example>
    </method_examples>
    <error_handling>
        <example id="1">
            <description>Basic try-catch for handling division by zero with logging.</description>
            <code>
                ```csharp
                /// <summary>
                /// DivisionCalculator.cs
                /// 
                /// Performs division operations safely.
                /// 
                /// Methods:
                ///     DivideSafely(float numerator, float denominator): Safely divides two numbers
                /// 
                /// Usage: Use in any calculation that requires division
                /// </summary>
                using UnityEngine;
                
                public class DivisionCalculator : MonoBehaviour
                {
                    private string _className;
                    
                    private void Awake()
                    {
                        _className = GetType().Name;
                    }
                    
                    /// <summary>
                    /// Safely divides two numbers.
                    /// </summary>
                    /// <param name="numerator">The numerator value</param>
                    /// <param name="denominator">The denominator value</param>
                    /// <returns>The result of division or 0 if denominator is 0</returns>
                    public float DivideSafely(float numerator, float denominator)
                    {
                        Debug.Log($"[{_className}] DivideSafely | numerator: {numerator} | denominator: {denominator}");
                        
                        try
                        {
                            if (Mathf.Approximately(denominator, 0f))
                            {
                                throw new System.DivideByZeroException();
                            }
                            
                            float result = numerator / denominator;
                            Debug.Log($"[{_className}] DivideSafely | result: {result}");
                            return result;
                        }
                        catch (System.DivideByZeroException)
                        {
                            Debug.LogError($"[{_className}] DivideSafely | Division by zero error");
                            return 0f;
                        }
                    }
                }
                ```
            </code>
        </example>

        <example id="2">
            <description>Handling multiple exceptions with finally clause using logging.</description>
            <code>
                ```csharp
                /// <summary>
                /// PlayerDataProcessor.cs
                /// 
                /// Processes player data from various sources.
                /// 
                /// Methods:
                ///     ProcessPlayerData(string playerId): Process data for a specific player
                /// 
                /// Usage: Use in game saving/loading systems
                /// </summary>
                using UnityEngine;
                using System;
                
                public class PlayerDataProcessor : MonoBehaviour
                {
                    private string _className;
                    
                    private void Awake()
                    {
                        _className = GetType().Name;
                    }
                    
                    /// <summary>
                    /// Processes player data from various sources.
                    /// </summary>
                    /// <param name="playerId">The player's unique identifier</param>
                    /// <returns>True if processing was successful, false otherwise</returns>
                    public bool ProcessPlayerData(string playerId)
                    {
                        Debug.Log($"[{_className}] ProcessPlayerData | playerId: {playerId}");
                        
                        if (string.IsNullOrEmpty(playerId))
                        {
                            Debug.LogError($"[{_className}] ProcessPlayerData | Player ID is null or empty");
                            return false;
                        }
                        
                        bool success = false;
                        
                        try
                        {
                            // Attempt to parse player ID as a GUID
                            Guid playerGuid = Guid.Parse(playerId);
                            
                            // Simulate processing player data
                            // In a real implementation, this would involve loading data
                            Debug.Log($"[{_className}] ProcessPlayerData | Successfully processed data for player: {playerGuid}");
                            success = true;
                        }
                        catch (FormatException)
                        {
                            Debug.LogError($"[{_className}] ProcessPlayerData | Invalid player ID format: {playerId}");
                        }
                        catch (Exception e)
                        {
                            Debug.LogError($"[{_className}] ProcessPlayerData | Unexpected error: {e.Message}");
                        }
                        finally
                        {
                            Debug.Log($"[{_className}] ProcessPlayerData | Operation complete");
                        }
                        
                        return success;
                    }
                }
                ```
            </code>
        </example>

        <example id="3">
            <description>Error handling for asset operations with logging, addressing missing assets and other unexpected errors.</description>
            <code>
                ```csharp
                /// <summary>
                /// AssetManager.cs
                /// 
                /// Manages loading and instantiation of game assets.
                /// 
                /// Methods:
                ///     InstantiatePrefab(string prefabPath): Instantiates a prefab from Resources
                /// 
                /// Usage: Use for dynamic loading of prefabs
                /// </summary>
                using UnityEngine;
                using System;
                
                public class AssetManager : MonoBehaviour
                {
                    private string _className;
                    
                    private void Awake()
                    {
                        _className = GetType().Name;
                    }
                    
                    /// <summary>
                    /// Instantiates a prefab from the Resources folder.
                    /// </summary>
                    /// <param name="prefabPath">Path to the prefab within Resources folder</param>
                    /// <returns>The instantiated GameObject or null if failed</returns>
                    public GameObject InstantiatePrefab(string prefabPath)
                    {
                        Debug.Log($"[{_className}] InstantiatePrefab | prefabPath: {prefabPath}");
                        
                        if (string.IsNullOrEmpty(prefabPath))
                        {
                            Debug.LogError($"[{_className}] InstantiatePrefab | Prefab path is null or empty");
                            return null;
                        }
                        
                        try
                        {
                            GameObject prefab = Resources.Load<GameObject>(prefabPath);
                            
                            if (prefab == null)
                            {
                                Debug.LogError($"[{_className}] InstantiatePrefab | Prefab not found at path: {prefabPath}");
                                return null;
                            }
                            
                            GameObject instance = Instantiate(prefab);
                            Debug.Log($"[{_className}] InstantiatePrefab | Successfully instantiated: {instance.name}");
                            return instance;
                        }
                        catch (Exception e)
                        {
                            Debug.LogError($"[{_className}] InstantiatePrefab | Error instantiating prefab: {e.Message}");
                            return null;
                        }
                    }
                }
                ```
            </code>
        </example>
    </error_handling>

    <input_validation>
        <example id="1">
            <description>Validating numeric input with logging.</description>
            <code>
                ```csharp
                /// <summary>
                /// InputValidator.cs
                /// 
                /// Validates user input for game configuration.
                /// 
                /// Methods:
                ///     ValidateNumericInput(string input, out int value): Validates numeric input
                /// 
                /// Usage: Use with UI input fields
                /// </summary>
                using UnityEngine;
                
                public class InputValidator : MonoBehaviour
                {
                    private string _className;
                    
                    private void Awake()
                    {
                        _className = GetType().Name;
                    }
                    
                    /// <summary>
                    /// Validates that input is a positive integer.
                    /// </summary>
                    /// <param name="input">The input string to validate</param>
                    /// <param name="value">The parsed value if valid</param>
                    /// <returns>True if input is valid, false otherwise</returns>
                    public bool ValidateNumericInput(string input, out int value)
                    {
                        Debug.Log($"[{_className}] ValidateNumericInput | input: {input}");
                        
                        value = 0;
                        
                        if (string.IsNullOrEmpty(input))
                        {
                            Debug.LogWarning($"[{_className}] ValidateNumericInput | Input is null or empty");
                            return false;
                        }
                        
                        if (int.TryParse(input, out value))
                        {
                            if (value >= 0)
                            {
                                Debug.Log($"[{_className}] ValidateNumericInput | Valid number: {value}");
                                return true;
                            }
                            else
                            {
                                Debug.LogWarning($"[{_className}] ValidateNumericInput | Negative number not allowed: {value}");
                                return false;
                            }
                        }
                        
                        Debug.LogWarning($"[{_className}] ValidateNumericInput | Invalid input, not a number: {input}");
                        return false;
                    }
                }
                ```
            </code>
        </example>

        <example id="2">
            <description>Validating an email address using regular expressions with logging.</description>
            <code>
                ```csharp
                /// <summary>
                /// EmailValidator.cs
                /// 
                /// Validates email address format.
                /// 
                /// Methods:
                ///     ValidateEmail(string email): Checks if an email is in valid format
                /// 
                /// Usage: Use with registration or login forms
                /// </summary>
                using UnityEngine;
                using System.Text.RegularExpressions;
                
                public class EmailValidator : MonoBehaviour
                {
                    private string _className;
                    private readonly string _emailPattern = @"^[\w\.-]+@[\w\.-]+\.\w+$";
                    
                    private void Awake()
                    {
                        _className = GetType().Name;
                    }
                    
                    /// <summary>
                    /// Validates an email address format.
                    /// </summary>
                    /// <param name="email">The email address to validate</param>
                    /// <returns>True if the email format is valid, false otherwise</returns>
                    public bool ValidateEmail(string email)
                    {
                        Debug.Log($"[{_className}] ValidateEmail | email: {email}");
                        
                        if (string.IsNullOrEmpty(email))
                        {
                            Debug.LogWarning($"[{_className}] ValidateEmail | Email is null or empty");
                            return false;
                        }
                        
                        bool isValid = Regex.IsMatch(email, _emailPattern);
                        
                        if (isValid)
                        {
                            Debug.Log($"[{_className}] ValidateEmail | Valid email address");
                        }
                        else
                        {
                            Debug.LogWarning($"[{_className}] ValidateEmail | Invalid email format");
                        }
                        
                        return isValid;
                    }
                }
                ```
            </code>
        </example>

        <example id="3">
            <description>Validating username requirements with logging, checking length and allowed characters.</description>
            <code>
                ```csharp
                /// <summary>
                /// UsernameValidator.cs
                /// 
                /// Validates username requirements.
                /// 
                /// Methods:
                ///     ValidateUsername(string username): Checks if a username meets requirements
                /// 
                /// Usage: Use with player registration or profile creation
                /// </summary>
                using UnityEngine;
                using System.Text.RegularExpressions;
                
                public class UsernameValidator : MonoBehaviour
                {
                    private string _className;
                    
                    [SerializeField] private int _minLength = 3;
                    [SerializeField] private int _maxLength = 20;
                    
                    private readonly string _allowedCharacters = @"^[a-zA-Z0-9_-]+$";
                    
                    private void Awake()
                    {
                        _className = GetType().Name;
                    }
                    
                    /// <summary>
                    /// Validates that a username meets length and character requirements.
                    /// </summary>
                    /// <param name="username">The username to validate</param>
                    /// <returns>True if the username is valid, false otherwise</returns>
                    public bool ValidateUsername(string username)
                    {
                        Debug.Log($"[{_className}] ValidateUsername | username: {username} | minLength: {_minLength} | maxLength: {_maxLength}");
                        
                        if (string.IsNullOrEmpty(username))
                        {
                            Debug.LogWarning($"[{_className}] ValidateUsername | Username is null or empty");
                            return false;
                        }
                        
                        if (username.Length < _minLength)
                        {
                            Debug.LogWarning($"[{_className}] ValidateUsername | Username too short; must be at least {_minLength} characters");
                            return false;
                        }
                        
                        if (username.Length > _maxLength)
                        {
                            Debug.LogWarning($"[{_className}] ValidateUsername | Username too long; must be at most {_maxLength} characters");
                            return false;
                        }
                        
                        if (!Regex.IsMatch(username, _allowedCharacters))
                        {
                            Debug.LogWarning($"[{_className}] ValidateUsername | Username contains invalid characters");
                            return false;
                        }
                        
                        Debug.Log($"[{_className}] ValidateUsername | Username is valid");
                        return true;
                    }
                }
                ```
            </code>
        </example>
    </input_validation>
</examples> 