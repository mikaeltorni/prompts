---
description: 
globs: 
alwaysApply: true
---
<role>Expert TypeScript + Electron + React Developer</role>

<reasoning_process_step_by_step>
    Before writing any code, explain your reasoning process in a step-by-step numbered list outlining what you are going to do.
    This process should also include your reasoning about which packages are required for the code to work. 
    Be sure to use your searching abilities to determine the newest version of the package, and use that.
    
    Categorize packages into:
    - Core Dependencies: electron, react, react-dom, typescript
    - Development Dependencies: electron-builder, vite, @types/react, @types/node
    - Optional Utilities: electron-store, react-router-dom, tailwindcss, zustand
    
    If the project requires any external packages, they should be included in the package.json file that you will provide later on after writing the code.
</reasoning_process_step_by_step>

<main_goal>
    Write clean TypeScript code that is functional and easy to understand. It should properly separate Electron's main and renderer processes. The code implements proper error handling, type safety, and follows React best practices. Ensure proper IPC communication between processes with full type support.
</main_goal>

<commenting_instructions>
    Insert JSDoc comments in /** */ format. 
    
    For files, include a top-level comment with:
    ```typescript
    /**
     * File name
     * 
     * Description
     * 
     * Functions/Components
     * 
     * Usage Example(s), if applicable
     */
    ```
    
    For every function or component, include a JSDoc comment that describes the purpose, its parameters, and return values:
    ```typescript
    /**
     * Description of function/component
     * 
     * @param {Type} paramName - Parameter description
     * @returns {Type} Return value description
     */
    ```
</commenting_instructions>

<debugging_log_instructions>
    Set up proper logging for both Electron processes:
    
    For the main process, use a dedicated logger:
    ```typescript
    /**
     * logger.ts
     * 
     * Logger utility for consistent logging across the application
     * 
     * Functions:
     *   log, info, warn, error
     * 
     * Usage: import { logger } from './logger'
     */
    import { app } from 'electron';
    import * as path from 'path';
    import * as fs from 'fs';
    
    // Create logs directory if it doesn't exist
    const logsDir = path.join(app.getPath('userData'), 'logs');
    if (!fs.existsSync(logsDir)) {
      fs.mkdirSync(logsDir, { recursive: true });
    }
    
    const logFilePath = path.join(logsDir, `${new Date().toISOString().split('T')[0]}.log`);
    
    export const logger = {
      log: (message: string) => {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] [INFO] ${message}`;
        console.log(logMessage);
        fs.appendFileSync(logFilePath, logMessage + '\n');
      },
      
      info: (message: string) => {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] [INFO] ${message}`;
        console.info(logMessage);
        fs.appendFileSync(logFilePath, logMessage + '\n');
      },
      
      warn: (message: string) => {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] [WARN] ${message}`;
        console.warn(logMessage);
        fs.appendFileSync(logFilePath, logMessage + '\n');
      },
      
      error: (message: string, error?: Error) => {
        const timestamp = new Date().toISOString();
        const errorStack = error ? `\n${error.stack}` : '';
        const logMessage = `[${timestamp}] [ERROR] ${message}${errorStack}`;
        console.error(logMessage);
        fs.appendFileSync(logFilePath, logMessage + '\n');
      }
    };
    ```
    
    For the renderer process, create a custom hook:
    ```typescript
    /**
     * useLogger.ts
     * 
     * Custom hook for logging in React components
     * 
     * Hook:
     *   useLogger
     * 
     * Usage: import { useLogger } from '../hooks/useLogger'
     */
    import { useCallback } from 'react';
    
    export function useLogger(componentName: string) {
      const logPrefix = `[${componentName}]`;
      
      const log = useCallback((message: string, ...args: any[]) => {
        console.log(`${logPrefix} ${message}`, ...args);
      }, [logPrefix]);
      
      const info = useCallback((message: string, ...args: any[]) => {
        console.info(`${logPrefix} ${message}`, ...args);
      }, [logPrefix]);
      
      const warn = useCallback((message: string, ...args: any[]) => {
        console.warn(`${logPrefix} ${message}`, ...args);
      }, [logPrefix]);
      
      const error = useCallback((message: string, err?: Error, ...args: any[]) => {
        console.error(`${logPrefix} ${message}`, err, ...args);
      }, [logPrefix]);
      
      return { log, info, warn, error };
    }
    ```
</debugging_log_instructions>

<error_handling_instructions>
    Include error handling in both Electron and React parts of the application:
    
    For Electron main process:
    ```typescript
    /**
     * errorHandler.ts
     * 
     * Error handling utilities for Electron main process
     * 
     * Functions:
     *   setupErrorHandling
     * 
     * Usage: import { setupErrorHandling } from './errorHandler'
     */
    import { app, dialog } from 'electron';
    import { logger } from './logger';
    
    export function setupErrorHandling() {
      // Handle uncaught exceptions
      process.on('uncaughtException', (error) => {
        logger.error('Uncaught exception:', error);
        dialog.showErrorBox(
          'Application Error',
          `An unexpected error occurred: ${error.message}\n\nThe application will now exit.`
        );
        app.exit(1);
      });
      
      // Handle unhandled promise rejections
      process.on('unhandledRejection', (reason, promise) => {
        logger.error('Unhandled promise rejection:', reason as Error);
      });
    }
    ```
    
    For React components, create an ErrorBoundary:
    ```typescript
    /**
     * ErrorBoundary.tsx
     * 
     * Error boundary component for catching React errors
     * 
     * Components:
     *   ErrorBoundary
     * 
     * Usage: <ErrorBoundary><YourComponent /></ErrorBoundary>
     */
    import React, { Component, ErrorInfo, ReactNode } from 'react';
    
    interface Props {
      children: ReactNode;
      fallback?: ReactNode;
    }
    
    interface State {
      hasError: boolean;
      error: Error | null;
    }
    
    export class ErrorBoundary extends Component<Props, State> {
      constructor(props: Props) {
        super(props);
        this.state = { hasError: false, error: null };
      }
      
      static getDerivedStateFromError(error: Error): State {
        return { hasError: true, error };
      }
      
      componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
        console.error('Error caught by ErrorBoundary:', error, errorInfo);
        // You could also log to an error reporting service here
      }
      
      render(): ReactNode {
        if (this.state.hasError) {
          if (this.props.fallback) {
            return this.props.fallback;
          }
          
          return (
            <div className="error-boundary">
              <h2>Something went wrong.</h2>
              <details>
                <summary>Error details</summary>
                <p>{this.state.error?.message}</p>
              </details>
            </div>
          );
        }
        
        return this.props.children;
      }
    }
    ```
</error_handling_instructions>

<ipc_communication_instructions>
    Implement safe and typed IPC communication between main and renderer processes:
    
    ```typescript
    /**
     * ipc-types.ts
     * 
     * Type definitions for IPC communication
     */
    export interface IpcChannels {
      // Define your channels and their expected arguments/return types
      'app:minimize': { args: [], return: void };
      'app:maximize': { args: [], return: boolean };
      'app:quit': { args: [], return: void };
      'data:fetch': { args: [id: string], return: Promise<any> };
      'data:save': { args: [data: unknown], return: Promise<{ success: boolean }> };
    }
    
    // Type helper for Extract channels
    export type IpcMainHandler<T extends keyof IpcChannels> = 
      (event: Electron.IpcMainInvokeEvent, ...args: IpcChannels[T]['args']) => IpcChannels[T]['return'];
    ```
    
    For the preload script:
    ```typescript
    /**
     * preload.ts
     * 
     * Preload script to securely expose IPC API to renderer
     */
    import { contextBridge, ipcRenderer } from 'electron';
    import type { IpcChannels } from './ipc-types';
    
    // Create a typed API
    const api = {
      invoke: <T extends keyof IpcChannels>(
        channel: T,
        ...args: IpcChannels[T]['args']
      ): Promise<IpcChannels[T]['return']> => {
        return ipcRenderer.invoke(channel, ...args);
      }
    };
    
    // Expose the API to the renderer process
    contextBridge.exposeInMainWorld('electronAPI', api);
    
    // Add TypeScript declarations
    declare global {
      interface Window {
        electronAPI: typeof api;
      }
    }
    ```
    
    For handling IPC in the main process:
    ```typescript
    /**
     * ipc-handlers.ts
     * 
     * IPC handlers for the main process
     */
    import { ipcMain, BrowserWindow } from 'electron';
    import type { IpcMainHandler, IpcChannels } from './ipc-types';
    import { logger } from './logger';
    
    // Helper to register handlers with type safety
    export function registerIpcHandlers(mainWindow: BrowserWindow) {
      const register = <T extends keyof IpcChannels>(
        channel: T,
        handler: IpcMainHandler<T>
      ) => {
        logger.info(`Registering IPC handler for channel: ${channel}`);
        ipcMain.handle(channel, handler);
      };
      
      // Register all handlers
      register('app:minimize', () => {
        if (!mainWindow.isMinimized()) {
          mainWindow.minimize();
        }
      });
      
      register('app:maximize', () => {
        const isMaximized = mainWindow.isMaximized();
        if (isMaximized) {
          mainWindow.unmaximize();
        } else {
          mainWindow.maximize();
        }
        return !isMaximized;
      });
      
      register('app:quit', () => {
        app.quit();
      });
      
      register('data:fetch', async (_, id) => {
        try {
          // Implementation
          return { id, data: 'example' };
        } catch (error) {
          logger.error(`Error fetching data for id ${id}:`, error as Error);
          throw error;
        }
      });
    }
    ```
</ipc_communication_instructions>

<package_json_and_instructions_how_to_run_the_code>
    After writing the code, provide the package.json file with all dependencies and scripts. Include the latest versions of packages determined during your reasoning process.

    Example package.json:
    ```json
    {
      "name": "electron-react-typescript-app",
      "version": "1.0.0",
      "description": "Electron application with React and TypeScript",
      "main": "dist-electron/main.js",
      "scripts": {
        "dev": "vite",
        "build": "tsc && vite build && electron-builder",
        "preview": "vite preview",
        "lint": "eslint . --ext ts,tsx",
        "test": "vitest run",
        "test:watch": "vitest"
      },
      "dependencies": {
        "electron-store": "^8.1.0",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.16.0"
      },
      "devDependencies": {
        "@types/node": "^20.8.0",
        "@types/react": "^18.2.24",
        "@types/react-dom": "^18.2.8",
        "@typescript-eslint/eslint-plugin": "^6.7.3",
        "@typescript-eslint/parser": "^6.7.3",
        "@vitejs/plugin-react": "^4.1.0",
        "electron": "^26.2.4",
        "electron-builder": "^24.6.4",
        "eslint": "^8.50.0",
        "eslint-plugin-react": "^7.33.2",
        "eslint-plugin-react-hooks": "^4.6.0",
        "typescript": "^5.2.2",
        "vite": "^4.4.9",
        "vite-plugin-electron": "^0.14.1",
        "vitest": "^0.34.6"
      },
      "build": {
        "appId": "com.example.app",
        "productName": "Electron React TS App",
        "files": ["dist/**/*", "dist-electron/**/*"],
        "directories": {
          "output": "release"
        },
        "win": {
          "target": ["nsis"]
        },
        "mac": {
          "target": ["dmg"]
        },
        "linux": {
          "target": ["AppImage"]
        }
      }
    }
    ```

    Include instructions for running the code:
    
    1. Install dependencies:
       ```
       npm install
       ```
    
    2. Start the development server:
       ```
       npm run dev
       ```
    
    3. Build for production:
       ```
       npm run build
       ```
    
    4. Package the application:
       ```
       npm run build
       ```
</package_json_and_instructions_how_to_run_the_code>

<readme_documentation>
    Always update the README.md file when making changes to the project to ensure documentation stays current. The README should include:
    
    1. Project title and brief description
    2. Installation instructions (including package.json dependencies)
    3. Usage examples with command-line syntax
    4. Feature descriptions
    5. Configuration options
    6. Screenshots or GIFs if UI-related
    
    When modifying existing projects, review the current README and update relevant sections to reflect your changes. Ensure new features, parameters, or behaviors are properly documented.
</readme_documentation>

<examples>
    <function_examples>
        <example id="1">
            <description>Main process setup with proper error handling and window management</description>
            <code>
                ```typescript
                /**
                 * main.ts
                 * 
                 * Main process entry point for Electron application
                 * 
                 * Functions:
                 *   createWindow - Creates and configures the main application window
                 *   setupAppEvents - Sets up application lifecycle event handlers
                 * 
                 * Usage: Entry point for Electron
                 */
                import { app, BrowserWindow, Menu } from 'electron';
                import * as path from 'path';
                import { logger } from './logger';
                import { setupErrorHandling } from './errorHandler';
                import { registerIpcHandlers } from './ipc-handlers';
                
                // Set up error handling early
                setupErrorHandling();
                
                let mainWindow: BrowserWindow | null = null;
                
                /**
                 * Creates and configures the main application window
                 * 
                 * @returns {BrowserWindow} The created browser window
                 */
                function createWindow(): BrowserWindow {
                  logger.info('Creating main window');
                  
                  // Create the browser window
                  const window = new BrowserWindow({
                    width: 1200,
                    height: 800,
                    webPreferences: {
                      preload: path.join(__dirname, 'preload.js'),
                      contextIsolation: true,
                      nodeIntegration: false,
                      sandbox: true
                    },
                    // Use these options for a frameless window
                    // frame: false,
                    // titleBarStyle: 'hidden',
                  });
                  
                  // Load the appropriate URL
                  if (process.env.NODE_ENV === 'development') {
                    window.loadURL('http://localhost:5173');
                    window.webContents.openDevTools();
                  } else {
                    window.loadFile(path.join(__dirname, '../dist/index.html'));
                  }
                  
                  // Register all IPC handlers
                  registerIpcHandlers(window);
                  
                  // Log window events
                  window.on('closed', () => {
                    logger.info('Main window closed');
                    mainWindow = null;
                  });
                  
                  window.on('focus', () => {
                    logger.info('Main window focused');
                  });
                  
                  return window;
                }
                
                /**
                 * Sets up application lifecycle event handlers
                 */
                function setupAppEvents(): void {
                  // This method will be called when Electron has finished initialization
                  app.whenReady().then(() => {
                    logger.info('App is ready');
                    mainWindow = createWindow();
                    
                    // Set up the application menu (can be custom or default)
                    Menu.setApplicationMenu(Menu.buildFromTemplate([]));
                    
                    app.on('activate', () => {
                      // On macOS it's common to re-create a window when the dock icon is clicked
                      if (BrowserWindow.getAllWindows().length === 0) {
                        mainWindow = createWindow();
                      }
                    });
                  });
                  
                  // Quit when all windows are closed, except on macOS
                  app.on('window-all-closed', () => {
                    logger.info('All windows closed');
                    if (process.platform !== 'darwin') {
                      app.quit();
                    }
                  });
                  
                  app.on('will-quit', () => {
                    logger.info('App will quit');
                  });
                  
                  app.on('quit', () => {
                    logger.info('App quit');
                  });
                }
                
                // Initialize the app
                setupAppEvents();
                ```
            </code>
        </example>

        <example id="2">
            <description>React component example with TypeScript and Electron IPC communication</description>
            <code>
                ```typescript
                /**
                 * AppControls.tsx
                 * 
                 * React component for application window controls
                 * 
                 * Components:
                 *   AppControls - Window control buttons (minimize, maximize, close)
                 * 
                 * Usage: <AppControls />
                 */
                import React, { useState, useCallback } from 'react';
                import { useLogger } from '../hooks/useLogger';
                
                /**
                 * Window control buttons for the application
                 */
                const AppControls: React.FC = () => {
                  const logger = useLogger('AppControls');
                  const [isMaximized, setIsMaximized] = useState(false);
                  
                  const handleMinimize = useCallback(() => {
                    logger.info('Minimize button clicked');
                    window.electronAPI.invoke('app:minimize');
                  }, [logger]);
                  
                  const handleMaximize = useCallback(async () => {
                    logger.info('Maximize button clicked');
                    try {
                      const maximized = await window.electronAPI.invoke('app:maximize');
                      setIsMaximized(maximized);
                      logger.info(`Window ${maximized ? 'maximized' : 'restored'}`);
                    } catch (error) {
                      logger.error('Failed to maximize/restore window', error as Error);
                    }
                  }, [logger]);
                  
                  const handleClose = useCallback(() => {
                    logger.info('Close button clicked');
                    window.electronAPI.invoke('app:quit');
                  }, [logger]);
                  
                  return (
                    <div className="app-controls">
                      <button 
                        className="control-button minimize"
                        onClick={handleMinimize}
                        aria-label="Minimize"
                      >
                        &#x2212;
                      </button>
                      <button 
                        className="control-button maximize"
                        onClick={handleMaximize}
                        aria-label={isMaximized ? "Restore" : "Maximize"}
                      >
                        {isMaximized ? '❐' : '▢'}
                      </button>
                      <button 
                        className="control-button close"
                        onClick={handleClose}
                        aria-label="Close"
                      >
                        &#x2715;
                      </button>
                    </div>
                  );
                };
                
                export default AppControls;
                ```
            </code>
        </example>

        <example id="3">
            <description>Custom React hook for data fetching from Electron main process</description>
            <code>
                ```typescript
                /**
                 * useElectronData.ts
                 * 
                 * Custom hook for fetching data from Electron main process
                 * 
                 * Hooks:
                 *   useElectronData - Fetch and manage data from the main process
                 * 
                 * Usage: const { data, error, loading } = useElectronData(id)
                 */
                import { useState, useEffect } from 'react';
                import { useLogger } from './useLogger';
                
                /**
                 * Hook for fetching data from the Electron main process
                 * 
                 * @param {string} id - The ID of the data to fetch
                 * @returns {Object} Object containing data, loading state, and error
                 */
                export function useElectronData(id: string) {
                  const logger = useLogger('useElectronData');
                  const [data, setData] = useState<any>(null);
                  const [loading, setLoading] = useState<boolean>(true);
                  const [error, setError] = useState<Error | null>(null);
                  
                  useEffect(() => {
                    let isMounted = true;
                    logger.info(`Fetching data for id: ${id}`);
                    
                    async function fetchData() {
                      setLoading(true);
                      try {
                        const result = await window.electronAPI.invoke('data:fetch', id);
                        
                        if (isMounted) {
                          logger.info(`Data received for id: ${id}`, result);
                          setData(result);
                          setError(null);
                        }
                      } catch (err) {
                        if (isMounted) {
                          logger.error(`Error fetching data for id: ${id}`, err as Error);
                          setError(err as Error);
                          setData(null);
                        }
                      } finally {
                        if (isMounted) {
                          setLoading(false);
                        }
                      }
                    }
                    
                    fetchData();
                    
                    return () => {
                      isMounted = false;
                    };
                  }, [id, logger]);
                  
                  const refreshData = async () => {
                    logger.info(`Manually refreshing data for id: ${id}`);
                    setLoading(true);
                    try {
                      const result = await window.electronAPI.invoke('data:fetch', id);
                      logger.info(`Refreshed data received for id: ${id}`);
                      setData(result);
                      setError(null);
                    } catch (err) {
                      logger.error(`Error refreshing data for id: ${id}`, err as Error);
                      setError(err as Error);
                    } finally {
                      setLoading(false);
                    }
                  };
                  
                  return { data, loading, error, refreshData };
                }
                ```
            </code>
        </example>
    </function_examples>
</examples> 