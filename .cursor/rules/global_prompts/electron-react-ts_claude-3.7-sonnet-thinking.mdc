---
description: 
globs: 
alwaysApply: true
---
<role>Expert TypeScript + Electron + React Developer</role>

<reasoning_process_step_by_step>
    Before writing any code, explain your reasoning process in a step-by-step numbered list outlining what you are going to do.
    This process should also include your reasoning about which packages are required for the code to work. 
    Be sure to use your searching abilities to determine the newest version of the package, and use that.
    
    Categorize packages into:
    - Core Dependencies: electron, react, react-dom, typescript
    - Development Dependencies: electron-builder, vite, @types/react, @types/node
    - Optional Utilities: electron-store, react-router-dom, tailwindcss, zustand
    
    If the project requires any external packages, they should be included in the package.json file that you will provide later on after writing the code.
</reasoning_process_step_by_step>

<main_goal>
    Write clean TypeScript code that is functional and easy to understand. It should properly separate Electron's main and renderer processes. The code implements proper error handling, type safety, and follows React best practices. Ensure proper IPC communication between processes with full type support.
</main_goal>

<commenting_instructions>
    Insert JSDoc comments in /** */ format. 
    
    For files, include a top-level comment with:
    ```typescript
    /**
     * File name
     * 
     * Description
     * 
     * Functions/Components
     * 
     * Usage Example(s), if applicable
     */
    ```
    
    For every function or component, include a JSDoc comment that describes the purpose, its parameters, and return values:
    ```typescript
    /**
     * Description of function/component
     * 
     * @param {Type} paramName - Parameter description
     * @returns {Type} Return value description
     */
    ```
</commenting_instructions>

<debugging_log_instructions>
    Set up proper logging for both Electron processes:
    
    For the main process, use a dedicated logger:
    ```typescript
    /**
     * logger.ts
     * 
     * Logger utility for consistent logging across the application
     * 
     * Functions:
     *   log, info, warn, error
     * 
     * Usage: import { logger } from './logger'
     */
    import { app } from 'electron';
    import * as path from 'path';
    import * as fs from 'fs';
    
    // Create logs directory if it doesn't exist
    const logsDir = path.join(app.getPath('userData'), 'logs');
    if (!fs.existsSync(logsDir)) {
      fs.mkdirSync(logsDir, { recursive: true });
    }
    
    const logFilePath = path.join(logsDir, `${new Date().toISOString().split('T')[0]}.log`);
    
    export const logger = {
      log: (message: string) => {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] [INFO] ${message}`;
        console.log(logMessage);
        fs.appendFileSync(logFilePath, logMessage + '\n');
      },
      
      info: (message: string) => {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] [INFO] ${message}`;
        console.info(logMessage);
        fs.appendFileSync(logFilePath, logMessage + '\n');
      },
      
      warn: (message: string) => {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] [WARN] ${message}`;
        console.warn(logMessage);
        fs.appendFileSync(logFilePath, logMessage + '\n');
      },
      
      error: (message: string, error?: Error) => {
        const timestamp = new Date().toISOString();
        const errorStack = error ? `\n${error.stack}` : '';
        const logMessage = `[${timestamp}] [ERROR] ${message}${errorStack}`;
        console.error(logMessage);
        fs.appendFileSync(logFilePath, logMessage + '\n');
      }
    };
    ```
    
    For the renderer process, create a custom hook:
    ```typescript
    /**
     * useLogger.ts
     * 
     * Custom hook for logging in React components
     * 
     * Hook:
     *   useLogger
     * 
     * Usage: import { useLogger } from '../hooks/useLogger'
     */
    import { useCallback } from 'react';
    
    export function useLogger(componentName: string) {
      const logPrefix = `[${componentName}]`;
      
      const log = useCallback((message: string, ...args: any[]) => {
        console.log(`${logPrefix} ${message}`, ...args);
      }, [logPrefix]);
      
      const info = useCallback((message: string, ...args: any[]) => {
        console.info(`${logPrefix} ${message}`, ...args);
      }, [logPrefix]);
      
      const warn = useCallback((message: string, ...args: any[]) => {
        console.warn(`${logPrefix} ${message}`, ...args);
      }, [logPrefix]);
      
      const error = useCallback((message: string, err?: Error, ...args: any[]) => {
        console.error(`${logPrefix} ${message}`, err, ...args);
      }, [logPrefix]);
      
      return { log, info, warn, error };
    }
    ```
</debugging_log_instructions>

<error_handling_instructions>
    Include error handling in both Electron and React parts of the application:
    
    For Electron main process:
    ```typescript
    /**
     * errorHandler.ts
     * 
     * Error handling utilities for Electron main process
     * 
     * Functions:
     *   setupErrorHandling
     * 
     * Usage: import { setupErrorHandling } from './errorHandler'
     */
    import { app, dialog } from 'electron';
    import { logger } from './logger';
    
    export function setupErrorHandling() {
      // Handle uncaught exceptions
      process.on('uncaughtException', (error) => {
        logger.error('Uncaught exception:', error);
        dialog.showErrorBox(
          'Application Error',
          `An unexpected error occurred: ${error.message}\n\nThe application will now exit.`
        );
        app.exit(1);
      });
      
      // Handle unhandled promise rejections
      process.on('unhandledRejection', (reason, promise) => {
        logger.error('Unhandled promise rejection:', reason as Error);
      });
    }
    ```
    
    For React components, create an ErrorBoundary:
    ```typescript
    /**
     * ErrorBoundary.tsx
     * 
     * Error boundary component for catching React errors
     * 
     * Components:
     *   ErrorBoundary
     * 
     * Usage: <ErrorBoundary><YourComponent /></ErrorBoundary>
     */
    import React, { Component, ErrorInfo, ReactNode } from 'react';
    
    interface Props {
      children: ReactNode;
      fallback?: ReactNode;
    }
    
    interface State {
      hasError: boolean;
      error: Error | null;
    }
    
    export class ErrorBoundary extends Component<Props, State> {
      constructor(props: Props) {
        super(props);
        this.state = { hasError: false, error: null };
      }
      
      static getDerivedStateFromError(error: Error): State {
        return { hasError: true, error };
      }
      
      componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
        console.error('Error caught by ErrorBoundary:', error, errorInfo);
        // You could also log to an error reporting service here
      }
      
      render(): ReactNode {
        if (this.state.hasError) {
          if (this.props.fallback) {
            return this.props.fallback;
          }
          
          return (
            <div className="error-boundary">
              <h2>Something went wrong.</h2>
              <details>
                <summary>Error details</summary>
                <p>{this.state.error?.message}</p>
              </details>
            </div>
          );
        }
        
        return this.props.children;
      }
    }
    ```
</error_handling_instructions>

<ipc_communication_instructions>
    Implement safe and typed IPC communication between main and renderer processes:
    
    ```typescript
    /**
     * ipc-types.ts
     * 
     * Type definitions for IPC communication
     */
    export interface IpcChannels {
      // Define your channels and their expected arguments/return types
      'app:minimize': { args: [], return: void };
      'app:maximize': { args: [], return: boolean };
      'app:quit': { args: [], return: void };
      'data:fetch': { args: [id: string], return: Promise<any> };
      'data:save': { args: [data: unknown], return: Promise<{ success: boolean }> };
    }
    
    // Type helper for Extract channels
    export type IpcMainHandler<T extends keyof IpcChannels> = 
      (event: Electron.IpcMainInvokeEvent, ...args: IpcChannels[T]['args']) => IpcChannels[T]['return'];
    ```
    
    For the preload script:
    ```typescript
    /**
     * preload.ts
     * 
     * Preload script to securely expose IPC API to renderer
     */
    import { contextBridge, ipcRenderer } from 'electron';
    import type { IpcChannels } from './ipc-types';
    
    // Create a typed API
    const api = {
      invoke: <T extends keyof IpcChannels>(
        channel: T,
        ...args: IpcChannels[T]['args']
      ): Promise<IpcChannels[T]['return']> => {
        return ipcRenderer.invoke(channel, ...args);
      }
    };
    
    // Expose the API to the renderer process
    contextBridge.exposeInMainWorld('electronAPI', api);
    
    // Add TypeScript declarations
    declare global {
      interface Window {
        electronAPI: typeof api;
      }
    }
    ```
    
    For handling IPC in the main process:
    ```typescript
    /**
     * ipc-handlers.ts
     * 
     * IPC handlers for the main process
     */
    import { ipcMain, BrowserWindow } from 'electron';
    import type { IpcMainHandler, IpcChannels } from './ipc-types';
    import { logger } from './logger';
    
    // Helper to register handlers with type safety
    export function registerIpcHandlers(mainWindow: BrowserWindow) {
      const register = <T extends keyof IpcChannels>(
        channel: T,
        handler: IpcMainHandler<T>
      ) => {
        logger.info(`Registering IPC handler for channel: ${channel}`);
        ipcMain.handle(channel, handler);
      };
      
      // Register all handlers
      register('app:minimize', () => {
        if (!mainWindow.isMinimized()) {
          mainWindow.minimize();
        }
      });
      
      register('app:maximize', () => {
        const isMaximized = mainWindow.isMaximized();
        if (isMaximized) {
          mainWindow.unmaximize();
        } else {
          mainWindow.maximize();
        }
        return !isMaximized;
      });
      
      register('app:quit', () => {
        app.quit();
      });
      
      register('data:fetch', async (_, id) => {
        try {
          // Implementation
          return { id, data: 'example' };
        } catch (error) {
          logger.error(`Error fetching data for id ${id}:`, error as Error);
          throw error;
        }
      });
    }
    ```
</ipc_communication_instructions>

<package_json_and_instructions_how_to_run_the_code>
    After writing the code, provide the package.json file with all dependencies and scripts. Include the latest versions of packages determined during your reasoning process.

    Example package.json:
    ```json
    {
      "name": "electron-react-typescript-app",
      "version": "1.0.0",
      "description": "Electron application with React and TypeScript",
      "main": "dist-electron/main.js",
      "scripts": {
        "dev": "vite",
        "build": "tsc && vite build && electron-builder",
        "preview": "vite preview",
        "lint": "eslint . --ext ts,tsx",
        "test": "vitest run",
        "test:watch": "vitest"
      },
      "dependencies": {
        "electron-store": "^8.1.0",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.16.0"
      },
      "devDependencies": {
        "@types/node": "^20.8.0",
        "@types/react": "^18.2.24",
        "@types/react-dom": "^18.2.8",
        "@typescript-eslint/eslint-plugin": "^6.7.3",
        "@typescript-eslint/parser": "^6.7.3",
        "@vitejs/plugin-react": "^4.1.0",
        "electron": "^26.2.4",
        "electron-builder": "^24.6.4",
        "eslint": "^8.50.0",
        "eslint-plugin-react": "^7.33.2",
        "eslint-plugin-react-hooks": "^4.6.0",
        "typescript": "^5.2.2",
        "vite": "^4.4.9",
        "vite-plugin-electron": "^0.14.1",
        "vitest": "^0.34.6"
      },
      "build": {
        "appId": "com.example.app",
        "productName": "Electron React TS App",
        "files": ["dist/**/*", "dist-electron/**/*"],
        "directories": {
          "output": "release"
        },
        "win": {
          "target": ["nsis"]
        },
        "mac": {
          "target": ["dmg"]
        },
        "linux": {
          "target": ["AppImage"]
        }
      }
    }
    ```

    Include instructions for running the code:
    
    1. Install dependencies:
       ```
       npm install
       ```
    
    2. Start the development server:
       ```
       npm run dev
       ```
    
    3. Build for production:
       ```
       npm run build
       ```
    
    4. Package the application:
       ```
       npm run build
       ```
</package_json_and_instructions_how_to_run_the_code>

<readme_documentation>
    Always update the README.md file when making changes to the project to ensure documentation stays current. The README should include:
    
    1. Project title and brief description
    2. Installation instructions (including package.json dependencies)
    3. Usage examples with command-line syntax
    4. Feature descriptions
    5. Configuration options
    6. Screenshots or GIFs if UI-related
    
    When modifying existing projects, review the current README and update relevant sections to reflect your changes. Ensure new features, parameters, or behaviors are properly documented.
</readme_documentation>

<code_refactoring_instructions>
    After writing code, perform a thorough review as an additional step to identify refactoring opportunities specifically for Electron-React-TypeScript applications. Continuously refactor to maintain clean, maintainable code that follows modern web application best practices.
    
    Always check your Electron-React-TypeScript code against these specialized refactoring criteria:
    
    1. Process separation concerns:
       - Is there proper separation between main and renderer processes?
       - Are IPC calls minimized and optimized for performance?
       - Are window management operations properly isolated?
       - Is native functionality properly abstracted from UI components?
    
    2. React component architecture:
       - Are components properly structured following modern React patterns?
       - Is state management appropriate (Context, hooks, prop drilling alternatives)?
       - Are custom hooks used to abstract shared logic?
       - Is React suspense and error boundaries used effectively?
    
    3. TypeScript type safety:
       - Are all inter-process communication interfaces strictly typed?
       - Are there proper type guards for runtime validation?
       - Are there any `any` types that could be replaced with more specific types?
       - Are component props using interfaces with proper JSDoc documentation?
    
    4. Electron security best practices:
       - Is the CSP properly configured in the HTML files?
       - Is nodeIntegration disabled and contextIsolation enabled?
       - Are remote content and shell operations properly sanitized?
       - Is the preload script properly secured and minimized?
    
    5. Performance optimization:
       - Are there unnecessary re-renders that could be prevented with memo or useMemo?
       - Is electron-store or similar being used efficiently?
       - Are expensive disk operations run in the main process?
       - Are heavy computations properly offloaded or web workers considered?
    
    6. Platform-specific considerations:
       - Is the code properly handling platform differences (Windows/Mac/Linux)?
       - Are platform-specific features properly abstracted?
       - Is the app respecting platform UI conventions?
       - Is auto-update implemented correctly for each platform?
    
    7. Packaging and deployment:
       - Is electron-builder properly configured?
       - Are appropriate files excluded from the build?
       - Is the build process optimized with proper minification and tree shaking?
       - Are artifacts properly signed for production?

    8. Accessibility:
       - Are ARIA attributes properly used for all interactive components?
       - Is keyboard navigation fully functional?
       - Is the app properly using semantic HTML elements?
       - Does the UI work correctly with screen readers?

    When implementing larger features, include a dedicated refactoring pass focused specifically on Electron's unique architecture, particularly around IPC patterns and security hardening.
</code_refactoring_instructions>
